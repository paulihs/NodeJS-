Redux背后的架构思想————认识Flux架构

Flux最核心之处就是‘单向数据流的设定’

在单向数据流下，状态的变化是可预测的。如果store中的数据发生了变化，那么只有一个原因，就是由Dispatcher派发Action来触发导致的。这样做的好处是从根本上避免了混乱的数据关系，使得流程变得清晰、简单。



为什么要保持单向数据流这个设定？

#### 传统MVC模式在前端场景的局限性

双向数据流最为典型的代表就是前端场景下的MVC架构。

![](E:\NodeJS-Study\笔记\React\mvc数据流向1.png)

在 MVC 应用中，会涉及这 3 个部分：

- Model（模型），程序需要操作的数据或信息；

- View（视图），用户界面；

- Controller（控制器），用于连接 View 和 Model，管理 Model 与 View 之间的逻辑。

原则上来说，三者的关系应该像上图一样，用户操作 View 后，由 Controller 来处理逻辑（或者直接触发 Controller 的逻辑），经过 Controller 将改变应用到 Model 中，最终再反馈到 View 上。在这个过程中，数据流应该是单向的。

**事实上，在许多服务端的 MVC 应用中，数据流确实能够保持单向。但是在前端场景下，实际的 MVC 应用要复杂不少，前端应用/框架往往出于交互的需要，允许 View 和 Model 直接通信。**

此时的架构关系就会变成下图这样：

![](E:\NodeJS-Study\笔记\React\mvc数据流向2.png)

这就允许了双向数据流的存在。当业务复杂度较高时，数据流会变得非常混乱，出现类似下图这种情况：

![](E:\NodeJS-Study\笔记\React\mvc数据流向3.png)

图中我们的示例只有一个 Controller，但考虑到一个应用中还可能存在多个 Controller，实际的情况应该比上图还要复杂得多（尽管图示本身已经够复杂了）。

在如此复杂的依赖关系下，再小的项目变更也将伴随着不容小觑的风险——或许一个小小的改动，就会对整个项目造成“蝴蝶效应”般的巨大影响。如此混乱的修改来源，将会使得我们连 Bug 排查都无从下手，因为你很难区分出一个数据的变化到底是由哪个 Controller 或者哪个 View 引发的。

此时再回头看下 Flux 的架构模式，你应该多少能感受到其中的妙处。这里我们再来回顾一下 Flux 中的数据流模式，请看下图：

![](E:\NodeJS-Study\笔记\React\redux单向数据流.png)

在单向数据流下，状态的变化是可预测的。如果store中的数据发生了变化，那么只有一个原因，就是由Dispatcher派发Action来触发导致的。这样做的好处是从根本上避免了混乱的数据关系，使得流程变得清晰、简单。

不过这并不意味着 Flux 是完美的。事实上，Flux 对数据流的约束背后是**不可忽视的成本**：除了开发者的**学习成本**会提升外，Flux 架构还意味着项目中**代码量的增加**。

Flux 架构往往在**复杂的项目**中才会体现出它的**优势和必要性**。如果项目中的数据关系并**不复杂**，其实完全**轮不到** Flux 登场，这一点对于 Redux 来说也是一样的。

现在你不妨结合 Flux 架构的特性，再去品味一遍 Redux 官方给出的这个定义：

> Redux 是 JavaScript 状态容器，它提供可预测的状态管理。

此时的你，想必更加能够体会“可预测”这三个字背后的深意。

#### Redux在设计上和Flux一脉相承

但是在实现上却不一样，Redux中只有一个store，在Flux中允许有多个。

Redux主要由三个部分组成：Store、Reducer和Action。

- Store： 唯一的数据源，而且是只读的。
- Action：“动作”，表示对变化的描述。
- Reducer: 一个函数，负责对变化进行分发和处理，将最新的数据返回给Store。

这三者紧密结合，形成了Redux独树一帜的工作流。如下图所示：

![](E:\NodeJS-Study\笔记\React\redux数据流.png)

在Redux的工作过程中，**数据流是严格单向的**。如果你想对数据进行修改，只有一个途径，发起一个Action。Action会被Reducer接收，Reducer会根据Action内容的不同执行不同的计算逻辑最终生成新的state（状态）

这个新的state会更新到Store对象中（其实是一个闭包），进而驱动视图层面的更新（利用Context）