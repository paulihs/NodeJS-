### React中的‘栈调和’

##### 什么是调和？

调和又叫‘协调’，协调的官方定义 体现在React官网对虚拟DOM这一概念的解释中。原文如下：

> Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。

总结一下就是： **通过如ReactDOM等类库使虚拟DOM与 ‘真实的DOM’同步，这个过程叫作‘协调’。**

##### Diff算法是‘调和’中的一个环节

‘调和’是将虚拟DOM映射到真实DOM的过程，这个过程中包含了找**差异（diff）**和**更新差异到真实DOM**中这两个环节。所以调和过程不能和Diff直接划等号，**Diff只是调和过程的一个环节**。

所以 `调和 !== Diff`, 不过在大众的认知里，当我们讨论调和的时候，其实就是在讨论Diff。



根据Diff实现形式的不同，调和过程被划分为以**React 15为代表的栈调和**以及**React 16的Fiber调和**。



##### Diff策略的设计思想

Diff算法就是找不同，在两个树结构之间找不同

#### 两个大前提

React团队结合设计层面的一些推导，总结了一下两个规律，为将O（n3）复杂度转换成O（n）复杂度确立了大前提：

- 若两个组件属于同一个类型，那么他们将拥有相同的DOM树形结构；
- 处于同一层级的一组子节点，可通过设置key作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性；

除了上面这两个规律之外，还有一个和事件结合比较紧密的规律，他为React实现高效的Diff提供了灵感：

DOM节点之间的跨层级操作并不多，**同层级操作是主流**。

下面我们就来看一下React是如何巧用这三个规律，打造高性能Diff的。

#### 把握三个‘要点’，图解Diff逻辑

要了解和掌握Diff逻辑，最主要的就是把握如下3个要点：

- ##### Diff算法性能突破的关键点在于‘分层对比’；
- ##### 只有类型一致的节点才有继续Diff的必要；
- ##### key属性的设置可以帮助我们尽可能的重用同一层级的节点；

这三个要点各自呼应上文中的三个规律，我们逐一来看：

1. #### 改变时间复杂度量级的决定性思路： 分层对比

结合“DOM节点之间的跨层级操作并不多， **同层级操作是主流**”这一规律，ReactDiff过程直接放弃了跨层级的节点比较，他只针对**相同层级的节点做对比**。这样一来，只要从上到下的一次遍历，就可以完成对整棵树的对比。这是降低复杂度量级方面的一个最重要的设计。

> 需要注意的是：虽然栈调和将传统的树对比算法优化为分层对比，但整个算法任然是以递归的形式运转的。
>
> 上面说到React在对比节点的时候，确实是从上到下做了一次遍历但是这个遍历是通过递归的方式完成的。而不是通过循环的方式。究其原因，是因为我们的虚拟dom是对象而不是数组。遍历方式的选择由数据结构决定。但是其最终的效果是一样的。
>
> React的diff算法是深度优先的遍历。



2. #### 减少递归的策略：只要类型一致才有Diff的必要

结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。

**本着抓“主要矛盾”的基本原则，React 认为，只有同类型的组件，才有进一步对比的必要性**；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点，如下图所示。只有确认组件类型相同后，React 才会在保留组件对应 DOM 树（或子树）的基础上，尝试向更深层次去 Diff。

这样一来，便能够从很大程度上减少 Diff 过程中冗余的递归操作。

3. #### 重用节点的好帮手： key属性帮React‘记住’节点

