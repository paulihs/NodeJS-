# 正则

###  元字符

| 特殊字符                                          | 正则表达式 |
| :------------------------------------------------ | ---------- |
| 换行符                                            | \n         |
| 回车符                                            | \r         |
| 空白符                                            | \s         |
| 除了换行符之外的任何字符                          | .          |
| 单个数字 [0-9]                                    | \d         |
| 除了数字                                          | \D         |
| 包括下划线在内的单个字符 字母数字，注意不包含汉字 | \w         |
| 不是单个字符，与\w正好相反                        | \W         |
| 匹配空白字符，包括空格，制表符，换页符 换行符     | \s         |
| 匹配非空白字符                                    | \S         |
| 匹配单词的边界                                    | \b         |
| 与\b相反 不匹配单词的边界                         | \B         |
| ^ 匹配字符串开始的位置                            | ^          |
| $ 匹配字符串结束的位置                            | $          |
|                                                   |            |



### 重复限定符

| 重复次数    | 正则表达式 |
| ----------- | ---------- |
| 0 ~ +∞      | *          |
| 1 ~ +∞      | +          |
| 0或者1      | ？         |
| 重复n次     | { n }      |
| 重复n到m次  | { n, m }   |
| 重复 n ~ +∞ | { n, }     |
|             |            |



### 分组

在正则中，限定符一般只修饰左边离它最近的那个字符，如果想修饰多个字符，我们可以使用括号 （），比如

/(ab)+/,这个正则匹配连续出现ab最少一次的情况。其中（ab）就是分组，又被称为子表达式。

#### 转义

有些字符在正则中函数特殊意义，如果想使用这些字符基本的用法，可以使用\修饰这些字符。

比如匹配一个网址

`/http:\/\/juejin\.im/`

#### 区间

[0-9A-Za-z]表示匹配数字和字母

在区间中的 . 号就表示 . 号，不匹配其他字符。

##### 否定区间

`/[^c]ar/`这个表达式匹配ar前面不是c的字符。如果是`/[^cde]ar`，那么它就不能匹配 car dar ear



条件或

（137 | 177）



或运算符就表示或，用作判断条件。

例如 `(T|t)he|car` 匹配 `(T|t)he` 或 `car`。

```JavaScript
"(T|t)he|car" => The car is parked in the garage.
```

匹配 the  、The、  car



#### 零宽度断言（前后预查）

1. 正先行断言 `?=...`

`?=...` 表示第一部分表达式之后必须跟着`?=...`定义的表达式。

起修饰约束的作用。断言一定要加括号。

```JavaScript
// reg匹配后面跟着空格fat ` fat`的the和The
let reg = /(T|t)he(?=\sfat)/;


// 匹配以空格fat开头的字符，但是返回的值 不包含空格fat
let reg2 = /^(?=\sfat)/
```

注意：断言只作为约束，匹配结果中是不包含的。而且先行断言和后发断言都是非捕获簇。



2. 负先行断言`?!...`

`?!...`表示 在第一部分表达式匹配的结果中，在筛选出其后不跟随断言中定义的格式。

```JavaScript
// reg 匹配后面不跟 空格fat的the
let reg = /the(?!\sfat)/
```

3. 正后发断言 `?<=...` 筛选条件为其前跟随着断言中定义的格式。

```JavaScript
// 匹配前面跟着the空格 的fat
let reg = /(?<=the\s)fat/;
```



4. 负后发断言 `?<!...`筛选条件为 其前不跟随断言中定义的格式。

```JavaScript
// 匹配前面不跟随 the空格的 cat
let reg = /(?<!the\s)cat/
```



这里我们总结下： 

先行断言 断言表达式在后面。 

后发断言 断言表达式在前面

正 代表存在

负 代表排除





#### 标志

i 忽略大小写

g 全局搜索

m  多行修饰符



贪婪匹配和惰性匹配

正则表达式默认使用贪婪模式，在该模式下意味着会匹配尽可能长的子串。

我们可以使用`?`将贪婪模式转化为惰性匹配模式。

注意: `?`是用来限制重复限定符的

```JavaScript
//只要一匹配到at就结束
let reg = /.*?at/
```



练习： 

```JavaScript
const reg = /^([1-9][0-9]*|0{1})(\.[0-9]{1,2})?$/;
// 此表达式匹配 大于等于0的数字，同时保留两位小数 
```

https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md